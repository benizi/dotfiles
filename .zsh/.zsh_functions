if zmodload zsh/zselect 2> /dev/null ; then
  function sleep () {
    local arg t ext
    for arg ; do
      case $arg in
        (<->(.<->(#c,1))(#c,1)|.<->)) t=$(( arg * 100 )) ;;
        *) ext=true ;;
      esac
    done
    if (( $+ext )) ; then
      command sleep "$@"
      return $?
    fi
    zselect -t $t 2>/dev/null
  }
fi
function colormsg () { C=${1-RED} ; shift ; print -l "${(P)C}$*${NOCOLOR}" }
function error () { colormsg RED $@ }
function title () { print "\e]2;$1\007" }
function titlep () { title "$1" ; NOTITLE=1 }
alias nl='nl -ha -ba -fa -nln'
function commafy () { perl -lpwe '@F=split/(\s+)/,$_,-1;for(@F){next if/\D/;1 while s/(?<=\d)(?=\d\d\d\b)/,/}$_=join"",@F' }
function humanfy () { perl -lpwe '@F=split/(\s+)/,$_,-1;for(@F){last if /[^\s\d]/; next if not s/^([+\-]?)(\d+(?:\.\d+)?)$/$2/; my $s = $1; my $l = int(log($_||1)/log(1024)); my $conv = "KMGTP"; if ($l > 0 and $l <= length $conv) { my $si=substr $conv, $l-1, 1; $_ /= 1024 ** $l; $_ = sprintf "%5.1f\e[%dm%s\e[0m", $_, 31+$l, $si; } else { $_ = sprintf "%5.1f", $_ } 1 while s/(?<=\d)(?=\d\d\d\b)/,/} $_=join"",@F' }
function hex () { perl -lpwe 's/(\d+)/sprintf"(dec)%d (hex)%x",$1,$1/e' }
function count () { echo $#argv }
function countf () { perl -lwe '$a++for grep-f,@ARGV;print$a' $argv }
function with-size () { perl -lpwe '$_=join"\t",-s,$_' }
function with-time () { perl -lpwe '$_=join"\t",(stat)[9],$_' }
function epoch-to-localtime () { perl -lpwe 's.^(\d+)(?=\s|$).scalar localtime $1.e' }
function epoch-to-isotime () { perl -MPOSIX=strftime -lpwe 's.^(\d+)(?=\s|$).strftime "%Y-%m-%d\@%H:%M:%S%z", localtime $1.e' }
function with-time-human () { perl -lpwe '$_=join"\t",scalar(localtime((stat)[9])),$_' }
function total () { awk '{ t += $1 } END { print t ? t : 0 }' }
function running-avg () { awk '{ t += $1 ; print t/NR, "\t", $_ }' }
function running-total () { awk '{ t += $1 ; print t, "\t", $_ }' }
function total-size () { with-size | cut -f1 | total | commafy }
function sort-with-size () { with-size | sort -n }
function sort-by-size () { sort-with-size | cut -f2- }
function sort-with-time () { with-time | sort -n }
function sort-by-time () { sort-with-time | cut -f2- }
function factor-pretty () { factor $1 | perl -lanwe '@b=(shift @F); @x=(1); while (@F) { $f = shift @F; if ($f eq $b[-1]) { $x[-1]++; } else { push @b, $f; push @x, 1; } } print join " ", map { $b[$_].($x[$_] eq 1 ? "" : "^$x[$_]") } 0..$#b' }
function update-zsh () {
  pushd ~
  if [ -L .zshrc -o -L .zshenv ] ; then
    echo "Linked (no-op)"
  elif hg st -A .zshrc | grep -q . ; then
    echo "In HG (no-op)"
  else
    wget -O - http://benizi.com/zsh.tbz2 | tar -jxvf -
  fi
  popd
}
function lslvm () { for l in vgs pvs lvs ; do lvm $l ; done }
if [ -n "$INCYG" ] ; then
  function cyg () { reply=("$(cygpath -w $REPLY)") }
fi
function real () { reply=("$(readlink -f $REPLY)") }
function set-pulse-server () {
  xprop -root -f PULSE_SERVER 8s -set PULSE_SERVER "$1"
}
function unix2win () { eol.pl -pc | iconv -f UTF-8 -t UTF-16 }
function win2unix () { iconv -f UTF-16 -t UTF-8 | eol.pl }
function instagit () {
  local email
  local git
  git=(git)
  while [ $# -gt 0 ] ; do
    case "$1" in
      --dry*) git=(echo git)
      ;;
      *)
        if [ -z "$email" ] ; then
          email="$1"
        else
          print -r Unknown argument "$1"
        fi
      ;;
    esac
    shift
  done
  [ -n "$email" ] || read 'email?Email: '
  [[ $email = *@* ]] || email=$email@benizi.com
  $git init \
  && $git config user.email $email \
  && $git add . \
  && $git ci -a -m init
}
function current-linux () { cd $(readlink -f /lib/modules/$(uname -r)/source) }
function message () { notify-send -t 0 $argv }
function uniq () { command uniq $argv | perl -lpwe 's/^\s*(\d+)\s/$1\t/' }
function edit9 () {
  emulate -L zsh
  setopt err_return
  local path9=$1 temp=$(mktemp -t edit9.XXXXXXXX)
  (( $#path9 && $#temp )) || return 1
  {
    wmiir cat $path9 > $temp
    ${EDITOR:-vi} $temp
    wmiir write $path9 < $temp
  } always { rm $temp }
}
can-mail () {
  (( $+commands[mail] )) && return 0
  warn "Need to install mailx?"
  return 1
}
reminder () {
  can-mail || return 1
  echo Mailed Reminder | mail -s "$*" $EMAIL
}
with-mail () {
  local txt ret
  can-mail || return 1
  $argv
  ret=$?
  txt="$argv"
  (( ret )) && txt="[Ret: $ret] $txt"
  reminder $txt
  return $ret
}

shredx () {
  local arg
  local -a shred delete dirlist
  shred=( -exec shred -v {} \; )
  delete=( -delete )
  for arg ; do
    case $arg in
      -n|--dry*) shred=( -exec echo shred -v {} \; ) ;;
      -k|--keep) delete=() ;;
      *) dirlist+=( $arg ) ;;
    esac
  done
  find $dirlist -type f $shred $delete || return 1
  (( $#delete )) && find $dirlist -empty -delete
}

rsync-build () {
  sudo find /var/tmp/build-root/ -type f -iname \*.rpm \
  | perl -lpwe 's!(/.?RPMS)!/.$1!' \
  | xargs -iZ rsync -RPtv Z /usr/src/packages/
}

alias-function () {
  (( $# )) || { warn "alias-function function-name [saved-function-name]" ; return 1 }
  local fn=$1
  (( $+functions[$fn] )) || { warn "no such function: $fn" ; return 1 }
  local old_fn=${2:-_old_$fn}
  eval $old_fn$' () {\n'${functions[$fn]}$'\n}'
}

ruler () { perl -lwe 'print map sprintf(" 23456 %2d0", $_), 1..50' | less -SE }

f-it () {
  local file=${1:-~/tgmf}
  while read line ; do
    if (( $#line )) ; then
      printf '%%\n%s\n' "$line" >> $file
      strfile $file $file.dat
    fi
  done
}

revbump () {
  local pattern
  local -a versions
  versions=( **/version.rb )
  if (( $#versions == 1 )) ; then
    perl -i -pwe '/VERSION/ and s/(\d+)(?=["\x27])/$1 + 1/e' $versions \
      && git commit -am "Revision bump for $*"
    git tag v$(awk -F$'[\'"]' '/VERSION/ { print $2 }' $versions)
  else
    warn 'More than one version.rb?'
  fi
}

image() {
  if (( ! $+commands[file] )) || [[ "$(file -b --mime-type $REPLY)" != image/* ]]
  then reply=()
  else reply=($REPLY)
  fi
}

gemdoc() { open http://rubygems.org/gems/$1 }

# return true the first time called, false thereafter
typeset -A __first
first() {
  local key="$__last_command_number $*"
  local ret=$(( $+__first[$key] ))
  __first+=( $key 1 )
  return ret
}

first-or() { first "$@" || $@ }

loopy() {
  if (( ! $# )) || [[ "$1" = <-> ]]
  then first-or sleep ${1:-1}
  else first-or "$@"
  fi
}

curl-json() {
  local -a opts
  case "$*" in
    *-XPOST*|*-X\ POST*) opts+=( -H 'Content-Type: application/json' ) ;;
  esac
  curl -s -H 'Accept: application/json' $opts "$@"
}
curl-api() {
  local -a opts
  [[ -f token ]] && opts+=( -H "X-Forever-Authorization: $(<token)" )
  if [[ -f base_url ]] && [[ $1 = /* ]] ; then
    local url=$(<base_url)$1
    shift
    opts+=( $url )
  fi
  curl-json $opts "$@"
}
curl-api-post() { curl-api "$@" -H 'Content-Type: application/json' -X POST }

looks-like-env() {
  local -a lines
  (( $# )) || return 1
  [[ -f $1 ]] || return 1
  lines=( ${(f):-"$(<$1)"} )
  [[ "${lines[1]}" = [A-Z][A-Z_0-9]*=* ]]
}

.env() {
  local arg anyfile
  unset anyfile
  local -a opts
  while (( $# )) ; do
    arg=$1
    if looks-like-env $arg ; then
      opts+=( ${(f):-"$(<$arg)"} )
      anyfile=true
      shift
    elif [[ $arg = - ]] ; then
      opts=( - "${opts[@]}" )
      shift
    elif (( ! $+anyfile )) && [[ -f .env ]] ; then
      set -- .env "$@"
    else
      break
    fi
  done
  ${=dry+printf '%s\n'} env $opts "$@"
}

fail.() {
  local arg char color
  (( $# )) || set -- 0
  for arg ; do
    char=F color=red
    (( ! arg )) && char=. color=green
    printf '%s%s%s' ${(%):-"%F{$color}"} $char ${(%):-%f}
  done
}

repeat-status() {
  local ret streak streak_count k arg wait_for quit
  local -a rets
  local -A counts

  while (( $# )) ; do
    arg=$1
    if [[ $arg = <-> ]] ; then
      wait_for=$arg
      shift
    else
      break
    fi
  done

  (( $# )) || {
    warn "No command given to $0"
    return 1
  }

  unset quit
  setopt localtraps trapsasync
  trap 'quit=true' INT QUIT

  while (( ! $+quit )) ; do
    "$@"
    ret=$?
    (( ret & 128 )) && quit=true
    rets+=( $ret )
    if (( ! $+streak )) || (( streak != ret )) ; then
      streak_count=0
    fi
    (( streak_count++ ))
    streak=$ret
    counts[$ret]=$(( ${counts[$ret]:-0} + 1 ))
    fail. $rets
    printf '\n'
    for k in ${(onk)counts} ; do
      fail. $k
      printf ' %d ' $counts[$k]
    done
    printf '\ncurrent streak: '
    fail. $streak
    printf ' %d\n' $streak_count

    if (( ! streak )) && (( $+wait_for )) && (( wait_for == streak_count ))
    then quit=true
    fi
  done
}
