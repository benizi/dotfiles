#!/bin/sh

set -e +x

# Alter values to taste. These values are appropriate for running a second
# Docker daemon (if the first running daemon uses default values).

: ${exe=dockerd${suffix:-}}
: ${altname=altdocker} # basis for names for the alternate daemon
: ${bridge=$altname} # network bridge we'll create
: ${ip=10.100.100.1} # IP address of bridge
: ${prefix=24} # bits in routing prefix
: ${addr=$ip/$prefix} # bridge IP in CIDR notation

: ${base=$HOME/$altname} # base location for filenames
: ${dataflag=data-root} # set dataflag=graph for old Docker versions
: ${dataroot=$base/$dataflag} # base location for daemon's storage, etc.
: ${pidfile=$base/pidfile} # PID file location
: ${host=unix://$base/socket} # listening socket (in net.Dial notation)

case "$1" in
  (--dry) action=gen_rm_script ;;
  (--rm) action=demolish ;;
  (*) action=daemon ;;
esac
test $action = daemon || shift

## Extra options I need:
set -- \
  --dns=$ip \
  --storage-driver=btrfs \
  --exec-opt native.cgroupdriver=cgroupfs \
  "$@"

# Old `docker` had `docker daemon` subcommand, not standalone `dockerd`
case "${exe##*/}" in (docker|docker-*) set -- daemon "$@" ;; esac

gen_rm_script() {
  sudo btrfs su li / |
  awk -v subpre=${base#/}/ '
  1!=index($NF,subpre){next}
  !header++{print "printf \"%s\\\\000\""}
  {print $NF}
  END{
    if(header) {
      print "| sudo xargs -n 1 -0 -r printf \"]] %s\\\\n\" btrfs su de"
    }
  }
  ' |
  sed '$!s/$/ \\/'
}

demolish() {
  gen_rm_script
}

## Other modes
if test $action != daemon
then
  $action "@$"
  exit $?
fi

## Set up alternate network bridge
if ! ip link show $bridge 2> /dev/null | grep -q .
then
  sudo ip link add name $bridge type bridge
  sudo ip addr add $addr dev $bridge
  sudo ip link set dev $bridge up
fi

printf 'To use `docker` without having to specify the host, run:\n'
printf '  export DOCKER_HOST=%s\n' $host

mkdir -p $base
sudo "$exe" "$@" \
  --pidfile=$pidfile \
  --bridge=$bridge \
  --exec-root="$base" \
  --$dataflag="$dataroot" \
  --host=$host
