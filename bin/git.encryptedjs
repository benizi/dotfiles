#!/usr/bin/env ruby

def encrypting?
  !!(__FILE__ =~ /encrypt$/)
end

def contents
  @contents ||= $stdin.read
end

def lines
  @lines ||= contents.lines.to_a
end

def password
  `git config filter.encryptedjs.password || true`.chomp
end

def encrypted?
  !!((lines[0] || '') =~ /^benizi/)
end

def done?
  encrypting? == encrypted?
end

if done? || password.empty?
  # Already processed or no password
  $stdout.write(contents)
  exit
end

def prep(contents)
  if encrypting?
    "//OK\n#{contents}"
  else
    contents.lines.to_a[1..-2].map do |line|
      line.sub(/^"/, '').sub(/\\n" \+/, '')
    end.join
  end
end

def find_salt(input)
  require 'base64'
  cipher = Base64.decode64(input)
  return if cipher.size * 2 < input.size
  marker = 'Salted__'
  return unless cipher.start_with?(marker)
  cipher[marker.size, 8].unpack("H*")[0].upcase
end

def showsalt(input)
  input.tap do
    return unless salt = find_salt(input)
    warn "SALT=#{salt}"
  end
end

def use_salt?
  encrypting? && ENV.has_key?('SALT')
end

def command
  op = encrypting? ? '-e' : '-d'
  salt = use_salt? ? %Q{ -S #{ENV['SALT']}} : ''
  %Q{openssl enc #{op} -a -blowfish -pass #{password}} + salt
end

def post(result)
  if encrypting?
    ret = []
    ret << 'benizi.source ='
    ret += result.lines.map { |line| %Q{"#{line.chomp}\\n" +} }
    ret << '"";'
    ret.map { |line| line + "\n" }.join
  else
    first_line = result.lines.first.chomp
    abort "Bad decode (First line: #{first_line})" unless first_line == '//OK'
    result.lines.drop(1).join
  end
end

def process(input)
  IO.popen(command, 'r+') do |io|
    io.write input
    io.close_write
    io.read
  end
end

STAGES = %i[prep process post puts]

def sym_list(s)
  String === s ? s.split(/\W+/).map(&:downcase).map(&:to_sym) : s
end

def setup_salt!(list)
  return unless ENV['SHOWSALT']
  list.insert(list.find_index(encrypting? ? :post : :process), :showsalt)
end

def stages
  list = sym_list(ENV['ONLY'] || STAGES)
  list << :puts if (STAGES & list).any? && !list.include?(:puts)
  setup_salt!(list)
  list.uniq.select { |s| should_run?(s) }
end

def in?(var, stage, default = '')
  sym_list(ENV.fetch(var, default)).include?(stage.to_sym)
end

def should_run?(stage)
  !in?('SKIP', stage)
end

def run_stages(input)
  stages.reduce(input) { |ret, fn| send(fn, ret) }
end

run_stages(contents)
