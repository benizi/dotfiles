#!/usr/bin/perl
use strict;
use warnings;
use utf8;
use open qw/:std :utf8/;
use Encode 'decode_utf8';
$_ = do { my $v = eval { decode_utf8($_, Encode::FB_CROAK); }; $v // $_ } for @ARGV;

sub esc {
	sprintf '\e[%sm', join ';', @_
}

sub indexed_ansi {
	my ($i, $bg) = @_;
	esc $i + ($bg ? 40 : 30)
}

sub indexed_256 {
	my ($i, $bg) = @_;
	esc $bg ? 48 : 38, 5, $i
}

sub COLORS () { 0 + ($ENV{COLORS} || 256) }
sub HI () { COLORS == 256 }

my @available = (256, 88);
if (!grep $_ == COLORS, @available) {
	my $set = '{'.join(', ', @available).'}';
	die "Colors should be one of $set\nWas: ".COLORS."\n";
}

my @low = (
	[ 0x00, 0x00, 0x00 ],
	[ 0xcd, 0x00, 0x00 ],
	[ 0x00, 0xcd, 0x00 ],
	[ 0xcd, 0xcd, 0x00 ],
	# ? xterm 256-color : rxvt 88-color
	HI ? [ 0x00, 0x00, 0xee ] : [ 0x00, 0x00, 0xcd ],
	[ 0xcd, 0x00, 0xcd ],
	[ 0x00, 0xcd, 0xcd ],
	[ 0xe5, 0xe5, 0xe5 ],
	HI ? [ 0x7f, 0x7f, 0x7f ] : [ 0x4d, 0x4d, 0x4d ],
	[ 0xff, 0x00, 0x00 ],
	[ 0x00, 0xff, 0x00 ],
	[ 0xff, 0xff, 0x00 ],
	HI ? [ 0x5c, 0x5c, 0xff ] : [ 0x00, 0x00, 0xff ],
	[ 0xff, 0x00, 0xff ],
	[ 0x00, 0xff, 0xff ],
	[ 0xff, 0xff, 0xff ],
);

sub max_color { COLORS - 1 }
sub cube_start { 16 }
sub grey_start { HI ? 232 : 80 }
sub levels {
	HI
	? [0, map 95 + 40 * $_, 0..4]
	: [0x00, 0x8b, 0xcd, 0xff]
}
sub grey88 () { 23.18181818 }
sub grey_level {
	my $i = shift;
	HI
	? (8 + 10 * $i)
	: int((2 + $i + ($i > 0)) * grey88)
}

sub rgb_to_hex {
	sprintf "#%02x%02x%02x", @_
}

sub combos {
	my @ret = ([]);
	for (1..3) {
		my @newret;
		for my $v (@{levels()}) {
			push @newret, map [$v, @$_], @ret;
		}
		@ret = @newret;
	}
	[@ret]
}

sub indexed_rgb {
	my $i = shift;
	($i >= grey_start) ? (grey_level($i - grey_start)) x 3 :
	($i < cube_start) ? @{$low[$i]} :
	@{combos()->[$i - cube_start]}
}

print rgb_to_hex indexed_rgb $_ and print "\n" for 0..max_color;
