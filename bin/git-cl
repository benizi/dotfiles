#!/usr/bin/env perl
use 5.016;
use warnings;
use URI;
use Getopt::Long;

sub usage {
  die <<USAGE;
Usage: git $0 [options] repo [-- other args to git-clone]

Options:
  --dry   Dry run
USAGE
}

GetOptions(
  'dry' => \(my $dry = 0),
) or usage;

my ($repo) = @ARGV;
chomp(my $resolved = qx/git parse-url $repo/);

# Repo must resolve to a recognizable URL
my $uri = URI->new($resolved);
unless ($uri->has_recognized_scheme) {
  my %seen;
  my $msg = join '->', map "{$_}", grep !$seen{$_}++, $repo, $uri;
  die "Couldn't resolve $msg.\n";
}
(my $path = $uri->path) =~ s{^/}{};

# Upstream must be identifier-like
my $valid_upstream = qr/^[A-Za-z][\w\-]*$/;

# Use the first path component (without `.git`) if there are multiple segments
my $upstream = $path =~ m{^([^/]+)/} ? $1 : '';
$upstream =~ s/\.git$//;

# Otherwise, use the "scheme-like" portion of the short repo name
unless ($upstream =~ $valid_upstream) {
  $upstream = URI->new($repo)->scheme if $repo ne $uri;
}

# Add upstream arg if one was found
unshift @ARGV, -o => $upstream if $upstream;

# Construct the `git-clone` command, print it, and run it (unless `--dry`)
my @clone = (git => clone => @ARGV);
say "@clone";
exec { $clone[0] } @clone unless $dry;
