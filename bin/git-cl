#!/usr/bin/env perl
use 5.016;
use warnings;
use URI;
use Getopt::Long;

sub usage {
  die <<USAGE;
Usage: git $0 [options] repo [-- other args to git-clone]

Options:
  --dry   Dry run
  -u/--include-user  Prepend the username to the clone destination, e.g.:
     git $0 gh:benizi/dotfiles -> dotfiles
     git $0 -u gh:benizi/dotfiles -> benizi-dotfiles
USAGE
}

GetOptions(
  'dry' => \(my $dry = 0),
  'u|include-user' => \(my $hyphenated = 0),
) or usage;

usage unless @ARGV;
my ($repo, @extra) = splice @ARGV;
chomp(my $resolved = qx/git parse-url $repo/);

# Repo must resolve to a recognizable URL
my $uri = URI->new($resolved);
unless ($uri->scheme eq 'git' or $uri->has_recognized_scheme) {
  my %seen;
  my $msg = join '->', map "{$_}", grep !$seen{$_}++, $repo, $uri;
  die "Couldn't resolve $msg.\n";
}
(my $path = $uri->path) =~ s{^/}{};

# Upstream must be identifier-like
my $valid_upstream = qr/^[A-Za-z][\w\-]*$/;

# Use the first path component (without `.git`) if there are multiple segments
my $upstream = $path =~ m{^([^/]+)/} ? $1 : '';
$upstream =~ s/\.git$//;

# Otherwise, use the "scheme-like" portion of the short repo name
unless ($upstream =~ $valid_upstream) {
  $upstream = URI->new($repo)->scheme if $repo ne $uri;
}

# Construct destination if requested
my $dest;
$dest = join '-', $1, $2 if $hyphenated and $path =~ m{^([^/]+)/([^/]+)};

# Construct the `git-clone` command
my @clone = qw/git clone/;
push @clone, -o => $upstream if $upstream;
push @clone, $repo;
push @clone, $dest if $dest;
push @clone, @extra;

# Print it, and run it (unless `--dry`)
say "@clone";
exec { $clone[0] } @clone unless $dry;
