#!/usr/bin/env ruby

require 'json'
require 'open3'
require 'set'

DC = %q(docker-compose.yml)
DC_ENV = %q(.env)
DC_OVER = %q(docker-compose.override.yml)

LOCAL_CFG = File.expand_path("~/.config/DC")
load LOCAL_CFG if File.exists?(LOCAL_CFG)

DIR_BY_CMD ||= {}

EXPORT_IP = %w(DOCKER_HOST_IP)

@orig_env = ENV.to_h
@env = {}

def has_env?(key, env: nil)
  env = env || @orig_env
  env.has_key?(key) && env[key] != ""
end

@debug = has_env?("DC_DEBUG")

def debug(txt)
  $stderr.puts(txt) if @debug
end

def with_env(e, &func)
  orig = ENV.to_h
  ENV.replace(e)
  func.()
rescue
ensure
  ENV.replace(orig)
end

def compose_file_from_command
  cmd = File.basename($0)
  if dir = DIR_BY_CMD[cmd]
    debug "$0 «#{cmd}» -> expand(#{dir})"
    expand_compose_file(dir)
  end
end

def compose_file_from_args(args)
  return nil unless File.basename($0) == "dcf"
  expand_compose_file(args.first).tap do |ret|
    debug "«dcf filename» -> #{ret||"(none)"}"
  end
end

def expand_compose_file(path)
  return nil unless path
  return [path] if File.extname(path) == ".yml" || File.file?(path)

  if path["/"] && File.directory?(path)
    file = File.join(path, DC)
    [file] if File.file?(file)
  end.tap do |ret|
    debug "expand(#{path}) -> #{ret||"(none)"}"
  end
end

def add_override(files)
  files.flat_map do |file|
    over = File.join(File.dirname(file), DC_OVER)
    [file, over].select { |f| File.file?(f) }
  end
end

def split_compose_file_args(args)
  files, modified =
    if has_env?("COMPOSE_FILE")
      [[], args]
    elsif expanded = compose_file_from_command
      [expanded, args]
    elsif specified = compose_file_from_args(args)
      [specified, args.clone.drop(1)]
    else
      [[], args]
    end.tap do |fs, mod|
      debug "split(#{args.inspect}) -> #{fs.inspect} + #{mod.inspect}"
    end

  [add_override(files), modified]
end

def export_myip
  ip = %x(myip %docker0).chomp
  EXPORT_IP.each { |name| set_env_var(name, ip) }
end

def add_dotenv(files)
  return unless compose_file = files.first
  env = File.join(File.dirname(compose_file), DC_ENV)
  add_dotenv_file(env)
end

def add_dotenv_file(env)
  return unless File.file?(env)
  debug "Adding #{env}"
  File.open(env) do |fh|
    fh.each_line do |line|
      line.chomp!
      case line
      when /\A(\w+)=(.*)\Z/ then
        var, val = line.split(/=/, 2)
        set_env_var(var, val)
      when /\A#/, /\A\s*\Z/ then
        nil
      else
        $stderr.puts("Wrong format for line in #{env}:")
        $stderr.puts(line)
      end
    end
  end
end

def set_env_var(var, val, force: false)
  present = has_env?(var) || has_env?(var, env: @env)

  if force || !present
    debug "#{present ? "Forced" : "Exporting"} env #{{var => val}.inspect}"
    @env[var] = val
  else
    debug "NOT Setting #{var} (already: [#{@env[var] || @orig_env[var]}])"
  end
end

def export_compose_files(files)
  debug "export_compose_files(#{files.inspect})"
  return unless files.first
  set_env_var("COMPOSE_FILE", files.join(File::PATH_SEPARATOR), force: true)
end

def set_env(files)
  export_myip
  add_dotenv(files)
  export_compose_files(files)
end

def spawn_pgroup(env, *cmd)
  spawn(env, *cmd, pgroup: true)
end

def with_signal_trap(action=:IGNORE)
  sigs = %i(INT TERM QUIT)
  prev = sigs.map { |s| [s, Signal.trap(s, action)] }.to_h
  begin
    yield
  ensure
    prev.to_a.each { |s,t| Signal.trap(s, t) }
  end
end

def run_dc(args, target: Open3, method: :capture3)
  cmd = %w(docker-compose) + args
  dbg_target = (target == self) ? "self" : target.inspect
  debug "Running: #{dbg_target}.#{method}(#{cmd.inspect[1..-2]})"
  @env.to_a.sort.each { |(k,v)| debug "  #{{k => v}.inspect}" }
  target.send(method, @env, *cmd)
end

def run_dc_tee(args, method=:spawn_pgroup)
  pid = run_dc(args, target: self, method: method)
  handler = proc { |sig| Process.kill(sig, pid) }
  with_signal_trap(handler) { Process.wait pid }
end

def docker_labels(name, *images)
  want_all = name == "--all"
  fields = ".Config.Labels"
  fields = "index #{fields} #{name.to_json}" unless want_all
  format = "--format={{json (#{fields})}}"
  if images.empty?
    out, _, rc = Open3.capture3(*%w(docker-compose ps -q))
    raise unless rc.success?
    images = out.strip.split
  end
  out, _, rc = Open3.capture3(*["docker", "inspect", format, *images])
  raise unless rc.success?
  JSON.parse(%Q{[#{out.strip.lines.join(",")}]})
rescue
  []
end

def compose_project_name
  return @project_name if defined?(@project_name)
  out, _, rc = run_dc(%w(ps -q))
  raise unless rc.success?
  id = out.strip.split.first
  @project_name = docker_labels("com.docker.compose.project", id)
rescue
  nil
end

def running_services
  raise unless project = compose_project_name
  filter = "--filter=label=com.docker.compose.project=#{project}"
  out, _, rc = Open3.capture3(*["docker", "ps", "-q", filter])
  raise unless rc.success?
  docker_labels("com.docker.compose.service", *out.split)
rescue
  []
end

def compose_services
  out, _, rc = run_dc(%w(config --services))
  raise unless rc.success?
  out.lines.map(&:chomp!)
rescue
  []
end

def main(args)
  orig = args.clone

  files, args = split_compose_file_args(args)

  if has_env?("DC_COMPLETION")
    puts files.join(":")
    exit
  end

  cmd, *rest = args
  abort "No command specified" unless cmd

  set_env(files)

  @runner = [self, :system]
  case cmd
  when "info", "debug" then
    @debug = cmd == "debug"
    files, args = with_env(@orig_env) { split_compose_file_args(orig) }
    files.each { |f| puts "Docker compose file: #{f}" }
    (ENV.to_a - @orig_env.to_a).each do |(k,v)|
      puts "Added $#{k} = «#{v}»"
    end
  when "reup" then
    opts = []
    opts << rest.shift while rest.first && rest.first =~ /^-/
    abort "No service(s) specified" if rest.empty?
    run_dc_tee(%w(rm -s -f) + rest)
    run_dc_tee(%w(up) + opts + rest)
  when "restart" then
    run_dc_tee(%w(down --remove-orphans))
    run_dc_tee(%w(up) + rest)
  when "status" then
    running = Set[*running_services]
    all = Set[*compose_services]
    all.to_a.sort.each do |svc|
      puts [running.include?(svc), svc].join("\t")
    end
  else
    run_dc_tee(args, :spawn)
  end
end

main(ARGV.clone)
