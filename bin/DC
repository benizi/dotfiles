#!/usr/bin/env ruby

require 'json'
require 'open3'
require 'set'

DC = %q(docker-compose.yml)
DC_BIN = %q(docker-compose)
DC_ENV = %q(.env)
DC_OVER = %q(docker-compose.override.yml)

LOCAL_CFG = File.expand_path("~/.config/DC")
load LOCAL_CFG if File.exists?(LOCAL_CFG)

DIR_BY_CMD ||= {}

EXPORT_IP = %w(DOCKER_HOST_IP)

@orig_env = ENV.to_h
@env = {"DC_WRAPPED_ALREADY" => "1"}

def has_env?(key, env: nil)
  env = env || @orig_env
  env.has_key?(key) && env[key] != ""
end

@debug = has_env?("DC_DEBUG")
@wrapped = has_env?("DC_WRAPPED_ALREADY", env: @orig_env)

def debug(txt)
  $stderr.puts(txt) if @debug
end

def with_env(e, &func)
  orig = ENV.to_h
  ENV.replace(e)
  func.()
rescue
ensure
  ENV.replace(orig)
end

def compose_file_from_command
  cmd = File.basename(ENV["ARGV0"] || ENV["DC_CMD"] || $0)
  if dir = DIR_BY_CMD[cmd]
    debug "$0 «#{cmd}» -> expand(#{dir})"
    expand_compose_file(dir)
  end
end

def compose_file_from_args(args)
  return nil unless File.basename($0) == "dcf"
  expand_compose_file(args.first).tap do |ret|
    debug "«dcf filename» -> #{ret||"(none)"}"
  end
end

def expand_compose_file(path)
  return nil unless path
  return [path] if File.extname(path) == ".yml" || File.file?(path)

  if path["/"] && File.directory?(path)
    file = File.join(path, DC)
    [file] if File.file?(file)
  end.tap do |ret|
    debug "expand(#{path}) -> #{ret||"(none)"}"
  end
end

def add_override(files)
  files.flat_map do |file|
    over = File.join(File.dirname(file), DC_OVER)
    [file, over].select { |f| File.file?(f) }
  end
end

def split_compose_file_args(args)
  files, modified =
    if has_env?("COMPOSE_FILE")
      [[], args]
    elsif expanded = compose_file_from_command
      [expanded, args]
    elsif specified = compose_file_from_args(args)
      [specified, args.clone.drop(1)]
    elsif File.exists?(DC)
      [[DC], args.clone]
    else
      [[], args]
    end.tap do |fs, mod|
      debug "split(#{args.inspect}) -> #{fs.inspect} + #{mod.inspect}"
    end

  [add_override(files), modified]
end

def export_myip
  ip = %x(myip %docker0).chomp
  EXPORT_IP.each { |name| set_env_var(name, ip) }
end

def add_dotenv(files)
  return unless compose_file = files.first
  env = File.join(File.dirname(compose_file), DC_ENV)
  add_dotenv_file(env)
end

def add_dotenv_file(env)
  return unless File.file?(env)
  debug "Adding #{env}"
  File.open(env) do |fh|
    fh.each_line do |line|
      line.chomp!
      case line
      when /\A(\w+)=(.*)\Z/ then
        var, val = line.split(/=/, 2)
        set_env_var(var, val)
      when /\A#/, /\A\s*\Z/ then
        nil
      else
        $stderr.puts("Wrong format for line in #{env}:")
        $stderr.puts(line)
      end
    end
  end
end

def set_env_var(var, val, force: false)
  present = has_env?(var) || has_env?(var, env: @env)

  if force || !present
    debug "#{present ? "Forced" : "Exporting"} env #{{var => val}.inspect}"
    @env[var] = val
  else
    debug "NOT Setting #{var} (already: [#{@env[var] || @orig_env[var]}])"
  end
end

def export_compose_files(files)
  debug "export_compose_files(#{files.inspect})"
  return unless files.first
  set_env_var("COMPOSE_FILE", files.join(File::PATH_SEPARATOR), force: true)
end

def set_project_directory(files)
  return unless files.first
  @project_directory = File.dirname(files.first)
end

def set_env(files)
  export_myip
  add_dotenv(files)
  export_compose_files(files)
  set_project_directory(files)
end

def spawn_pgroup(env, *cmd)
  spawn(env, *cmd, pgroup: true)
end

def with_signal_trap(action=:IGNORE)
  sigs = %i(INT TERM QUIT)
  prev = sigs.map { |s| [s, Signal.trap(s, action)] }.to_h
  begin
    yield
  ensure
    prev.to_a.each { |s,t| Signal.trap(s, t) }
  end
end

def same_inode?(a, b)
  File::Stat.new(a).ino == File::Stat.new(b).ino
rescue
  false
end

def docker_compose_bin
  exts = ";#{ENV["PATHEXT"]}".split(";", -1).drop(1)
  ENV['PATH'].split(File::PATH_SEPARATOR).each do |dir|
    exts.each do |ext|
      bin = File.join(dir, "#{DC_BIN}#{ext}")
      next unless File.executable?(bin)
      next if File.directory?(bin)
      next if same_inode?(bin, __FILE__)
      return [bin]
    end
  end
end

def directory_flag
  @project_directory ? ["--project-directory", @project_directory] : []
end

def run_dc(args, target: Open3, method: :capture3)
  cmd = docker_compose_bin + directory_flag + args
  dbg_target = (target == self) ? "self" : target.inspect
  debug "Running: #{dbg_target}.#{method}(#{cmd.inspect[1..-2]})"
  @env.to_a.sort.each { |(k,v)| debug "  #{{k => v}.inspect}" }
  target.send(method, @env, *cmd)
end

def run_dc_tee(args, method=:spawn_pgroup)
  pid = run_dc(args, target: self, method: method)
  handler = proc { |sig| Process.kill(sig, pid) }
  with_signal_trap(handler) { Process.wait pid }
end

def docker_labels(name, *images)
  want_all = name == "--all"
  fields = ".Config.Labels"
  fields = "index #{fields} #{name.to_json}" unless want_all
  format = "--format={{json (#{fields})}}"
  if images.empty?
    out, _, rc = Open3.capture3(*%w(docker-compose ps -q))
    raise unless rc.success?
    images = out.strip.split
  end
  out, _, rc = Open3.capture3(*["docker", "inspect", format, *images])
  raise unless rc.success?
  JSON.parse(%Q{[#{out.strip.lines.join(",")}]})
rescue
  []
end

def compose_project_name
  return @project_name if defined?(@project_name)

  name = @env["COMPOSE_PROJECT_NAME"] || @orig_env["COMPOSE_PROJECT_NAME"]
  name ||= File.basename(@project_directory)
  @project_name = name if name
  return @project_name if defined?(@project_name)

  out, _, rc = run_dc(%w(ps -q))
  raise unless rc.success?
  id = out.strip.split.first
  docker_labels("com.docker.compose.project", id).first.tap do |name|
    debug "compose_project_name: #{name}"
    @project_name = name
  end
rescue
  nil
end

def running_services
  raise unless project = compose_project_name
  filter = "--filter=label=com.docker.compose.project=#{project}"
  out, _, rc = Open3.capture3(*["docker", "ps", "-q", filter])
  raise unless rc.success?
  docker_labels("com.docker.compose.service", *out.split)
rescue => x
  debug "running_services failed: #{x}"
  []
end

def compose_services
  out, _, rc = run_dc(%w(config --services))
  raise unless rc.success?
  out.lines.map(&:chomp!)
rescue => x
  debug "compose_services failed: #{x}"
  []
end

def already_wrapped?
  !!@wrapped
end

def main(args)
  orig = args.clone

  files, args = split_compose_file_args(args)

  if has_env?("DC_COMPLETION")
    puts files.join(":")
    exit
  end

  cmd, *rest = args
  abort "No command specified" unless cmd

  set_env(files)

  return run_dc_tee(args, :spawn) if already_wrapped?

  @runner = [self, :system]
  case cmd
  when "inspect" then
    out, _, rc = run_dc(%w(ps -q) + rest)
    raise unless rc.success?
    ids = out.strip.split
    out, _, rc = Open3.capture3(*["docker", "inspect", *ids])
    raise unless rc.success?
    puts out
  when "info", "debug" then
    @debug = cmd == "debug"
    files, args = with_env(@orig_env) { split_compose_file_args(orig) }
    files.each { |f| puts "Docker compose file: #{f}" }
    (ENV.to_a - @orig_env.to_a).each do |(k,v)|
      puts "Added $#{k} = «#{v}»"
    end
    puts "project_name = «#{compose_project_name}»"
  when "reup" then
    opts = []
    opts << rest.shift while rest.first && rest.first =~ /^-/
    abort "No service(s) specified" if rest.empty?
    run_dc_tee(%w(rm -s -f) + rest)
    run_dc_tee(%w(up) + opts + rest)
  when "restart" then
    run_dc_tee(%w(down --remove-orphans))
    run_dc_tee(%w(up) + rest)
  when "status" then
    running = Set[*running_services]
    all = Set[*compose_services]
    all.to_a.sort.each do |svc|
      puts [running.include?(svc), svc].join("\t")
    end
  when "scale" then
    scales = []
    svcs = []
    rest.each do |s|
      if m = s.match(/^(?<svc>[\w\-]+)=(?<n>\d+)$/)
        scales += ["--scale", s]
        svcs << m[:svc]
      elsif s =~ /^[\w\-]+$/
        svcs << s
      else
        abort "Args to 'scale' should be of the form 'service'/'service=N' (#{s})"
      end
    end
    run_dc_tee(%w(up -d) + scales + svcs)
  else
    run_dc_tee(args, :spawn)
  end
end

main(ARGV.clone)
